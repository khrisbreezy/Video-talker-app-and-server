{"ast":null,"code":"import { setLocalStream, callStates, setCallState, setCallingDialog, setCallerUsername, setCallRejected } from \"../../store/actions/call\";\nimport { sendPreOffer, sendPreOfferAnswer, sendWebRTCOffer, sendWebRTCAnswer, sendWebRTCCandidate } from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\"\n};\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE)); //   createPeerConnection();\n  }).catch(e => {\n    console.log(\"Error occured when user tried to get local stream\");\n    console.log(e);\n  });\n};\nexport const createPeerConnection = () => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = store.getState().call.localStream;\n\n  for (const track of localStream.getTracks()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  ;\n\n  peerConnection.ontrack = _ref => {// Dispatch remote stream to store\n\n    let {\n      streams: [stream]\n    } = _ref;\n  };\n\n  peerConnection.onicecandidate = event => {\n    // Send to connected user our ice candidate\n    console.log({\n      event\n    }, 'getting candidate from stun server');\n\n    if (event.candidate) {\n      sendWebRTCCandidate({\n        candidate: event.candidate,\n        connectedUserSocketId: connectedUserSocketId\n      });\n    }\n  };\n\n  peerConnection.onconnectionstatechange(event => {\n    if (peerConnection.connectionState === 'connected') {\n      console.log('sucessfully connected', {\n        event\n      });\n    }\n  });\n};\nexport const callToOther = activeUserDetails => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username\n    }\n  });\n};\nexport const handlePreoffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n};\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreofferAnswer = data => {\n  store.dispatch(setCallingDialog(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n\n    store.dispatch(setCallRejected({\n      rejection: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n  const offer = await peerConnection.createOffer();\n  await peerConnection.setLocalDescription(offer);\n  sendWebRTCOffer({\n    calleeSocketId: connectedUserSocketId,\n    offer: offer\n  });\n};\n\nexport const handleOffer = async data => {\n  await peerConnection.setRemoteDescription(data.offer);\n  const answer = await peerConnection.createAnswer();\n  await peerConnection.setLocalDescription(answer);\n  sendWebRTCAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: answer\n  });\n};\nexport const handleAnswer = async data => {\n  await peerConnection.setRemoteDescription(data.answer);\n};\nexport const handleCandidate = async data => {\n  console.log('Adding ice candidate', {\n    data\n  });\n\n  try {\n    await peerConnection.addIceCandidate(data.candidate);\n  } catch (e) {\n    console.log('Error occured when trying to add received ice candidate', e);\n  }\n}; // If user rejects call\n\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n}; // Check if call is possible\n\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};","map":{"version":3,"sources":["/Users/macuser/Desktop/Sites/React-Projects/VideoTalker/video-talker-app/src/utils/webRTC/webRTCHandler.js"],"names":["setLocalStream","callStates","setCallState","setCallingDialog","setCallerUsername","setCallRejected","sendPreOffer","sendPreOfferAnswer","sendWebRTCOffer","sendWebRTCAnswer","sendWebRTCCandidate","store","defaultConstrains","video","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","catch","e","console","log","createPeerConnection","RTCPeerConnection","localStream","getState","call","track","getTracks","addTrack","ontrack","streams","onicecandidate","event","candidate","onconnectionstatechange","connectionState","callToOther","activeUserDetails","socketId","CALL_IN_PROGRESS","callee","caller","username","dashReducer","handlePreoffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreofferAnswer","sendOffer","rejectionReason","rejection","reason","offer","createOffer","setLocalDescription","calleeSocketId","handleOffer","setRemoteDescription","createAnswer","handleAnswer","handleCandidate","addIceCandidate","CALL_UNAVAILABLE","callState"],"mappings":"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","sourcesContent":["import {\n  setLocalStream,\n  callStates,\n  setCallState,\n  setCallingDialog,\n  setCallerUsername,\n  setCallRejected\n} from \"../../store/actions/call\";\nimport {\n    sendPreOffer,\n    sendPreOfferAnswer,\n    sendWebRTCOffer,\n    sendWebRTCAnswer,\n    sendWebRTCCandidate\n} from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\n\nconst defaultConstrains = {\n  video: true,\n  audio: true,\n};\n\nconst configuration = {\n    iceServers: [{\n        urls: 'stun:stun.google.com:13902'\n    }]\n};\n\nlet connectedUserSocketId;\nlet peerConnection;\n\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\",\n};\n\nexport const getLocalStream = () => {\n  navigator.mediaDevices\n    .getUserMedia(defaultConstrains)\n    .then((stream) => {\n      store.dispatch(setLocalStream(stream));\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    //   createPeerConnection();\n    })\n    .catch((e) => {\n      console.log(\"Error occured when user tried to get local stream\");\n      console.log(e);\n    });\n};\n\nexport const createPeerConnection = () => {\n    peerConnection = new RTCPeerConnection(configuration);\n    const localStream = store.getState().call.localStream;\n\n    for(const track of localStream.getTracks()) {\n        peerConnection.addTrack(track, localStream);\n    };\n\n    peerConnection.ontrack = ({ streams: [stream] }) => {\n        // Dispatch remote stream to store\n    };\n\n    peerConnection.onicecandidate = (event) => {\n        // Send to connected user our ice candidate\n        console.log({event}, 'getting candidate from stun server');\n        if (event.candidate) {\n            sendWebRTCCandidate({\n                candidate: event.candidate,\n                connectedUserSocketId: connectedUserSocketId\n            })\n        }\n    };\n\n    peerConnection.onconnectionstatechange((event) => {\n        if (peerConnection.connectionState === 'connected') {\n            console.log('sucessfully connected', {event});\n        }\n    });\n\n};\n\nexport const callToOther = (activeUserDetails) => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username,\n    },\n  });\n};\n\nexport const handlePreoffer = (data) => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE,\n    });\n  }\n};\n\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED,\n  });\n};\n\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED,\n  });\n  resetCallData();\n};\n\nexport const handlePreofferAnswer = (data) => {\n    store.dispatch(setCallingDialog(false));\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason =\n        \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n    store.dispatch(setCallRejected({\n        rejection: true,\n        reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    sendWebRTCOffer({\n        calleeSocketId: connectedUserSocketId,\n        offer: offer\n    });\n};\n\nexport const handleOffer = async (data) => {\n    await peerConnection.setRemoteDescription(data.offer);\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    sendWebRTCAnswer({\n        callerSocketId: connectedUserSocketId,\n        answer: answer\n    });\n};\n\nexport const handleAnswer = async (data) => {\n    await peerConnection.setRemoteDescription(data.answer);\n};\n\nexport const handleCandidate = async (data) => {\n    console.log('Adding ice candidate', {data});\n    try {\n        await peerConnection.addIceCandidate(data.candidate);\n    } catch(e) {\n        console.log('Error occured when trying to add received ice candidate', e);\n    }\n};\n\n// If user rejects call\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n};\n\n// Check if call is possible\nexport const checkIfCallIsPossible = () => {\n  if (\n    store.getState().call.localStream === null ||\n    store.getState().call.callState !== callStates.CALL_AVAILABLE\n  ) {\n    return false;\n  } else {\n    return true;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}