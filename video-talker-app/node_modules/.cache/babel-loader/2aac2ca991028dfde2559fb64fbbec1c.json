{"ast":null,"code":"import { setLocalStream, callStates, setCallState, setCallingDialog, setCallerUsername, setCallRejected, setRemoteStream, setScreenSharingActive } from \"../../store/actions/call\";\nimport { sendPreOffer, sendPreOfferAnswer, sendWebRTCOffer, sendWebRTCAnswer, sendWebRTCCandidate, sendUserHangUp } from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\"\n};\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    createPeerConnection();\n  }).catch(e => {\n    console.log(\"Error occured when user tried to get local stream\");\n    console.log(e);\n  });\n};\nexport const createPeerConnection = () => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = store.getState().call.localStream;\n\n  for (const track of localStream.getTracks()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  ;\n\n  peerConnection.ontrack = _ref => {\n    let {\n      streams: [stream]\n    } = _ref;\n    console.log({\n      stream\n    }, 'remote stream');\n    store.dispatch(setRemoteStream(stream)); // Dispatch remote stream to store\n  };\n\n  peerConnection.onicecandidate = event => {\n    // Send to connected user our ice candidate\n    console.log({\n      event\n    }, 'getting candidate from stun server');\n\n    if (event.candidate) {\n      sendWebRTCCandidate({\n        candidate: event.candidate,\n        connectedUserSocketId: connectedUserSocketId\n      });\n    }\n  };\n\n  peerConnection.onconnectionstatechange = event => {\n    if (peerConnection.connectionState === 'connected') {\n      console.log('sucessfully connected with other peer', {\n        event\n      });\n    }\n  };\n};\nexport const callToOther = activeUserDetails => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username\n    }\n  });\n};\nexport const handlePreoffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n};\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreofferAnswer = data => {\n  store.dispatch(setCallingDialog(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n\n    store.dispatch(setCallRejected({\n      rejection: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n  const offer = await peerConnection.createOffer();\n  await peerConnection.setLocalDescription(offer);\n  sendWebRTCOffer({\n    calleeSocketId: connectedUserSocketId,\n    offer: offer\n  });\n};\n\nexport const handleOffer = async data => {\n  await peerConnection.setRemoteDescription(data.offer);\n  const answer = await peerConnection.createAnswer();\n  await peerConnection.setLocalDescription(answer);\n  sendWebRTCAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: answer\n  });\n};\nexport const handleAnswer = async data => {\n  await peerConnection.setRemoteDescription(data.answer);\n};\nexport const handleCandidate = async data => {\n  console.log('Adding ice candidate', {\n    data\n  });\n\n  try {\n    await peerConnection.addIceCandidate(data.candidate);\n  } catch (e) {\n    console.log('Error occured when trying to add received ice candidate', e);\n  }\n}; // If user rejects call\n\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n}; // Check if call is possible\n\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};\nlet screenSharingStream; // Function to share screen to other user\n\nexport const switchForScreenSharingStream = async () => {\n  if (!store.getState().call.screenSharing) {\n    try {\n      screenSharingStream = await navigator.mediaDevices.getDisplayMedia({\n        video: true\n      });\n      store.dispatch(setScreenSharingActive(true));\n      const senders = peerConnection.getSenders();\n      const sender = senders.find(sender => sender.track.kind === screenSharingStream.getVideoTracks()[0].kind);\n      sender.replaceTrack(screenSharingStream.getVideoTracks()[0]);\n    } catch (e) {\n      console.log('Error ocurred when trying to get screen sharinf stream', {\n        e\n      });\n    }\n  } else {\n    const localStream = store.getState().call.localStream;\n    const senders = peerConnection.getSenders();\n    const sender = senders.find(sender => sender.track.kind === localStream.getVideoTracks()[0].kind);\n    sender.replaceTrack(localStream.getVideoTracks()[0]);\n    store.dispatch(setScreenSharingActive(false));\n    screenSharingStream.getTracks().forEach(track => track.stop());\n  }\n};\nexport const hangUp = () => {\n  sendUserHangUp({\n    connectedUserSocketId: connectedUserSocketId\n  });\n  resetCallDataAfterHangUp();\n};\n\nconst resetCallDataAfterHangUp = () => {\n  store.dispatch(setRemoteStream(null));\n  peerConnection.close();\n  peerConnection = null;\n  createPeerConnection();\n};","map":{"version":3,"sources":["/Users/macuser/Desktop/Sites/React-Projects/VideoTalker/video-talker-app/src/utils/webRTC/webRTCHandler.js"],"names":["setLocalStream","callStates","setCallState","setCallingDialog","setCallerUsername","setCallRejected","setRemoteStream","setScreenSharingActive","sendPreOffer","sendPreOfferAnswer","sendWebRTCOffer","sendWebRTCAnswer","sendWebRTCCandidate","sendUserHangUp","store","defaultConstrains","video","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","createPeerConnection","catch","e","console","log","RTCPeerConnection","localStream","getState","call","track","getTracks","addTrack","ontrack","streams","onicecandidate","event","candidate","onconnectionstatechange","connectionState","callToOther","activeUserDetails","socketId","CALL_IN_PROGRESS","callee","caller","username","dashReducer","handlePreoffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreofferAnswer","sendOffer","rejectionReason","rejection","reason","offer","createOffer","setLocalDescription","calleeSocketId","handleOffer","setRemoteDescription","createAnswer","handleAnswer","handleCandidate","addIceCandidate","CALL_UNAVAILABLE","callState","screenSharingStream","switchForScreenSharingStream","screenSharing","getDisplayMedia","senders","getSenders","sender","find","kind","getVideoTracks","replaceTrack","forEach","stop","hangUp","resetCallDataAfterHangUp","close"],"mappings":"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","sourcesContent":["import {\n  setLocalStream,\n  callStates,\n  setCallState,\n  setCallingDialog,\n  setCallerUsername,\n  setCallRejected,\n  setRemoteStream,\n  setScreenSharingActive\n} from \"../../store/actions/call\";\nimport {\n    sendPreOffer,\n    sendPreOfferAnswer,\n    sendWebRTCOffer,\n    sendWebRTCAnswer,\n    sendWebRTCCandidate,\n    sendUserHangUp\n} from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\n\nconst defaultConstrains = {\n  video: true,\n  audio: true,\n};\n\nconst configuration = {\n    iceServers: [{\n        urls: 'stun:stun.google.com:13902'\n    }]\n};\n\nlet connectedUserSocketId;\nlet peerConnection;\n\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\",\n};\n\nexport const getLocalStream = () => {\n  navigator.mediaDevices\n    .getUserMedia(defaultConstrains)\n    .then((stream) => {\n      store.dispatch(setLocalStream(stream));\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n      createPeerConnection();\n    })\n    .catch((e) => {\n      console.log(\"Error occured when user tried to get local stream\");\n      console.log(e);\n    });\n};\n\nexport const createPeerConnection = () => {\n    peerConnection = new RTCPeerConnection(configuration);\n    const localStream = store.getState().call.localStream;\n\n    for(const track of localStream.getTracks()) {\n        peerConnection.addTrack(track, localStream);\n    };\n\n    peerConnection.ontrack = ({ streams: [stream] }) => {\n      console.log({stream}, 'remote stream');\n      store.dispatch(setRemoteStream(stream));\n        // Dispatch remote stream to store\n    };\n\n    peerConnection.onicecandidate = (event) => {\n        // Send to connected user our ice candidate\n        console.log({event}, 'getting candidate from stun server');\n        if (event.candidate) {\n            sendWebRTCCandidate({\n                candidate: event.candidate,\n                connectedUserSocketId: connectedUserSocketId\n            })\n        }\n    };\n\n    peerConnection.onconnectionstatechange = (event) => {\n        if (peerConnection.connectionState === 'connected') {\n            console.log('sucessfully connected with other peer', {event});\n        }\n    };\n\n};\n\nexport const callToOther = (activeUserDetails) => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username,\n    },\n  });\n};\n\nexport const handlePreoffer = (data) => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE,\n    });\n  }\n};\n\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED,\n  });\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n};\n\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED,\n  });\n  resetCallData();\n};\n\nexport const handlePreofferAnswer = (data) => {\n    store.dispatch(setCallingDialog(false));\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason =\n        \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n    store.dispatch(setCallRejected({\n        rejection: true,\n        reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    sendWebRTCOffer({\n        calleeSocketId: connectedUserSocketId,\n        offer: offer\n    });\n};\n\nexport const handleOffer = async (data) => {\n    await peerConnection.setRemoteDescription(data.offer);\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    sendWebRTCAnswer({\n        callerSocketId: connectedUserSocketId,\n        answer: answer\n    });\n};\n\nexport const handleAnswer = async (data) => {\n    await peerConnection.setRemoteDescription(data.answer);\n};\n\nexport const handleCandidate = async (data) => {\n    console.log('Adding ice candidate', {data});\n    try {\n        await peerConnection.addIceCandidate(data.candidate);\n    } catch(e) {\n        console.log('Error occured when trying to add received ice candidate', e);\n    }\n};\n\n// If user rejects call\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n};\n\n// Check if call is possible\nexport const checkIfCallIsPossible = () => {\n  if (\n    store.getState().call.localStream === null ||\n    store.getState().call.callState !== callStates.CALL_AVAILABLE\n  ) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nlet screenSharingStream;\n\n// Function to share screen to other user\nexport const switchForScreenSharingStream = async () => {\n  if (!store.getState().call.screenSharing) {\n    try {\n      screenSharingStream = await navigator.mediaDevices.getDisplayMedia({ video: true });\n      store.dispatch(setScreenSharingActive(true));\n      const senders = peerConnection.getSenders();\n      const sender = senders.find(sender => sender.track.kind === screenSharingStream.getVideoTracks()[0].kind);\n      sender.replaceTrack(screenSharingStream.getVideoTracks()[0]);\n    } catch(e) {\n      console.log('Error ocurred when trying to get screen sharinf stream', {e});\n    }\n  } else {\n    const localStream = store.getState().call.localStream;\n    const senders = peerConnection.getSenders();\n    const sender = senders.find(sender => sender.track.kind === localStream.getVideoTracks()[0].kind);\n    sender.replaceTrack(localStream.getVideoTracks()[0]);\n    store.dispatch(setScreenSharingActive(false));\n    screenSharingStream.getTracks().forEach(track => track.stop());\n  }\n};\n\nexport const hangUp = () => {\n  sendUserHangUp({\n    connectedUserSocketId: connectedUserSocketId\n  });\n\n  resetCallDataAfterHangUp();\n};\n\nconst resetCallDataAfterHangUp = () => {\n  store.dispatch(setRemoteStream(null));\n\n  peerConnection.close();\n  peerConnection = null;\n  createPeerConnection();\n}\n"]},"metadata":{},"sourceType":"module"}