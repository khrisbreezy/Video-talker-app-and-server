{"ast":null,"code":"import { setLocalStream, callStates, setCallState, setCallingDialog, setCallerUsername, setCallRejected } from \"../../store/actions/call\";\nimport { sendPreOffer, sendPreOfferAnswer, sendWebRTCOffer, sendWebRTCAnswer, sendWebRTCCandidate } from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\"\n};\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    console.log({\n      stream\n    });\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    createPeerConnection(stream);\n  }).catch(e => {\n    console.log(\"Error occured when user tried to get local stream\");\n    console.log(e);\n  });\n};\nexport const createPeerConnection = stream => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = stream;\n\n  for (const track of localStream.getTracks()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  ;\n\n  peerConnection.ontrack = _ref => {// Dispatch remote stream to store\n\n    let {\n      streams: [stream]\n    } = _ref;\n  };\n\n  peerConnection.onicecandidate = event => {\n    // Send to connected user our ice candidate\n    console.log({\n      event\n    }, 'getting candidate from stun server');\n\n    if (event.candidate) {\n      sendWebRTCCandidate({\n        candidate: event.candidate,\n        connectedUserSocketId: connectedUserSocketId\n      });\n    }\n  };\n\n  peerConnection.oniceconnectionstatechange(event => {\n    if (peerConnection.connectionState === 'connected') {\n      console.log('sucessfully connected', {\n        event\n      });\n    }\n  });\n};\nexport const callToOther = activeUserDetails => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username\n    }\n  });\n};\nexport const handlePreoffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n};\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreofferAnswer = data => {\n  store.dispatch(setCallingDialog(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n\n    store.dispatch(setCallRejected({\n      rejection: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n  const offer = await peerConnection.createOffer();\n  await peerConnection.setLocalDescription(offer);\n  sendWebRTCOffer({\n    calleeSocketId: connectedUserSocketId,\n    offer: offer\n  });\n};\n\nexport const handleOffer = async data => {\n  await peerConnection.setRemoteDescription(data.offer);\n  const answer = await peerConnection.createAnswer();\n  await peerConnection.setLocalDescription(answer);\n  sendWebRTCAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: answer\n  });\n};\nexport const handleAnswer = async data => {\n  await peerConnection.setRemoteDescription(data.answer);\n};\nexport const handleCandidate = async data => {\n  console.log('Adding ice candidate', {\n    data\n  });\n\n  try {\n    await peerConnection.addIceCandidate(data.candidate);\n  } catch (e) {\n    console.log('Error occured when trying to add received ice candidate', e);\n  }\n}; // If user rejects call\n\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n}; // Check if call is possible\n\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};","map":{"version":3,"sources":["/Users/macuser/Desktop/Sites/React-Projects/VideoTalker/video-talker-app/src/utils/webRTC/webRTCHandler.js"],"names":["setLocalStream","callStates","setCallState","setCallingDialog","setCallerUsername","setCallRejected","sendPreOffer","sendPreOfferAnswer","sendWebRTCOffer","sendWebRTCAnswer","sendWebRTCCandidate","store","defaultConstrains","video","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","console","log","dispatch","CALL_AVAILABLE","createPeerConnection","catch","e","RTCPeerConnection","localStream","track","getTracks","addTrack","ontrack","streams","onicecandidate","event","candidate","oniceconnectionstatechange","connectionState","callToOther","activeUserDetails","socketId","CALL_IN_PROGRESS","callee","caller","username","getState","dashReducer","handlePreoffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreofferAnswer","sendOffer","rejectionReason","rejection","reason","offer","createOffer","setLocalDescription","calleeSocketId","handleOffer","setRemoteDescription","createAnswer","handleAnswer","handleCandidate","addIceCandidate","CALL_UNAVAILABLE","call","callState"],"mappings":"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","sourcesContent":["import {\n  setLocalStream,\n  callStates,\n  setCallState,\n  setCallingDialog,\n  setCallerUsername,\n  setCallRejected\n} from \"../../store/actions/call\";\nimport {\n    sendPreOffer,\n    sendPreOfferAnswer,\n    sendWebRTCOffer,\n    sendWebRTCAnswer,\n    sendWebRTCCandidate\n} from \"../wssConnection/wssConnection\";\nimport store from \"../../store/store\";\n\nconst defaultConstrains = {\n  video: true,\n  audio: true,\n};\n\nconst configuration = {\n    iceServers: [{\n        urls: 'stun:stun.google.com:13902'\n    }]\n};\n\nlet connectedUserSocketId;\nlet peerConnection;\n\nconst preOfferAnswers = {\n  CALL_ACCEPTED: \"CALL_ACCEPTED\",\n  CALL_REJECTED: \"CALL_REJECTED\",\n  CALL_NOT_AVAILABLE: \"CALL_NOT_AVAILABLE\",\n};\n\nexport const getLocalStream = () => {\n  navigator.mediaDevices\n    .getUserMedia(defaultConstrains)\n    .then((stream) => {\n      console.log({ stream });\n      store.dispatch(setLocalStream(stream));\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n      createPeerConnection(stream);\n    })\n    .catch((e) => {\n      console.log(\"Error occured when user tried to get local stream\");\n      console.log(e);\n    });\n};\n\nexport const createPeerConnection = (stream) => {\n    peerConnection = new RTCPeerConnection(configuration);\n    const localStream = stream\n\n    for(const track of localStream.getTracks()) {\n        peerConnection.addTrack(track, localStream);\n    };\n\n    peerConnection.ontrack = ({ streams: [stream] }) => {\n        // Dispatch remote stream to store\n    };\n\n    peerConnection.onicecandidate = (event) => {\n        // Send to connected user our ice candidate\n        console.log({event}, 'getting candidate from stun server');\n        if (event.candidate) {\n            sendWebRTCCandidate({\n                candidate: event.candidate,\n                connectedUserSocketId: connectedUserSocketId\n            })\n        }\n    };\n\n    peerConnection.oniceconnectionstatechange((event) => {\n        if (peerConnection.connectionState === 'connected') {\n            console.log('sucessfully connected', {event});\n        }\n    });\n\n};\n\nexport const callToOther = (activeUserDetails) => {\n  connectedUserSocketId = activeUserDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialog(true));\n  sendPreOffer({\n    callee: activeUserDetails,\n    caller: {\n      username: store.getState().dashReducer.username,\n    },\n  });\n};\n\nexport const handlePreoffer = (data) => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE,\n    });\n  }\n};\n\nexport const acceptIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED,\n  });\n};\n\nexport const rejectIncomingCallRequest = () => {\n  sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED,\n  });\n  resetCallData();\n};\n\nexport const handlePreofferAnswer = (data) => {\n    store.dispatch(setCallingDialog(false));\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    // Send WebRTC Offer\n    sendOffer();\n  } else {\n    let rejectionReason;\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason =\n        \"Callee is not available to pick up the call right now!\";\n    } else {\n      rejectionReason = \"Callee rejected the call\";\n    }\n    store.dispatch(setCallRejected({\n        rejection: true,\n        reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n    const offer = await peerConnection.createOffer();\n    await peerConnection.setLocalDescription(offer);\n    sendWebRTCOffer({\n        calleeSocketId: connectedUserSocketId,\n        offer: offer\n    });\n};\n\nexport const handleOffer = async (data) => {\n    await peerConnection.setRemoteDescription(data.offer);\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    sendWebRTCAnswer({\n        callerSocketId: connectedUserSocketId,\n        answer: answer\n    });\n};\n\nexport const handleAnswer = async (data) => {\n    await peerConnection.setRemoteDescription(data.answer);\n};\n\nexport const handleCandidate = async (data) => {\n    console.log('Adding ice candidate', {data});\n    try {\n        await peerConnection.addIceCandidate(data.candidate);\n    } catch(e) {\n        console.log('Error occured when trying to add received ice candidate', e);\n    }\n};\n\n// If user rejects call\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_UNAVAILABLE));\n};\n\n// Check if call is possible\nexport const checkIfCallIsPossible = () => {\n  if (\n    store.getState().call.localStream === null ||\n    store.getState().call.callState !== callStates.CALL_AVAILABLE\n  ) {\n    return false;\n  } else {\n    return true;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}